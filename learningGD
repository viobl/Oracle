select*from tab;--실행은 ctrl enter
--DATABase를 이용하기 위해서는 이용하는자에대한 계정이 필요함
--관리자 권한이 있는 system계정으로 아이디와 패스워드를 부여해서 계정생성
--계정에 대한 설정을 할때는 system계정으로 접속한 후 해야한다

-- 계정생성 명령어! 오라클에서 계정을 USER라고 사용 *오라클 내에서 하나의 객체로 취급
-- create user 유저명 indentified by 비밀번호; * 기본생성명령 11G버전까지는 생성공간을 자동으로 설정해서 만들어 줬음
-- 18c create user 유저명 identifiedd by 비밀번호 default tablespace users quota unlimited on users;
-- bs 계정만들기
-- 18c는 기본적으로 계정을 생성할때 유저명에 c##을 붙여야함. c##을 붙이지 않으려면 설정을 변ㄴ경해야함
-- 관리자 계정으로 실행해야하고 접속을 끊고 다시 접속 할때마다 해줘야함 *계정을 생성한다면
alter session set "_ORACLE_SCRIPT"=true;--계정명에 c##안 붙이게하는 설정
create user bs identified by bs default tablespace users quota unlimited on users;
-- 사용자 계정을 만들었다면, 추가적으로 DB를 활용할수 있게 권한을 부여해줘야한다
-- 권한을 부여할때는 관리자계정(System)을 부여해야한다
-- 권한을 부여할때는 GRANT명령어를 이용함
-- 접속을 허용:connect, DB사용권한: resourse
-- GRANT 부여할 권한들[,권한,권한2] TO 사용자계정명
GRANT CONNECT, RESOURCE TO BS;

-- 관리자계정(system)은 DBMS를 전반적으로 관리하는 계정
-- 사용자조회, 모든 테이블 조회하거나 각계정의 테이블도 조회 가능
-- 관리자계정에는  DBMS에 대한 정보를 제공하는 테이블(data저장소)->dictionary
SELECT*FROM DICT;
-- 사용자 계정조회
SELECT*FROM DBA_USERS;

-- 실습하기위한 데이터 설치하기
-- 설치된 테이블 확인하기
SELECT*FROM TAB; -->계정이 가지고 있는 전체테이블을 조회하는 명령어
SELECT*FROM EMPLOYEE; --사원정보 저장테이블
SELECT*FROM DEPARTMENT;--부서
SELECT*FROM JOB;--직책
SELECT*FROM LOCATION;--근무지
SELECT*FROM SAL_GRADE;--급여
SELECT*FROM NATIONAL;--근무국가



--SELECT문 이용하기
--SELECT문은 지정한 테이블에 있는 조건 조회해서 출력해주는 명령어
-- 사용하는 방법
--SELECT 출력을 원하는 컬럼이 있으면 컬럼명을 작성[,컬럼명, 컬럼명]||전체 컬럼을 조회하려면 *
-- FROM 테이블명
-- [WHERE 조건식] 특정 ROW만 출력하고 싶을때 사용. 생략이 가능
-- EMPLOYEE테이블에 전체데이터 조회하기
SELECT*FROM EMPLOYEE;
SELECT*FROM TAB;
--EMPLOY 테이블에서 원하는 컬럼을 조회하기
--테이블에 어떤 컬럼이 있는지 확인
DESC EMPLOYEE;
-- EMPLOYEE에서 사원이름, 이메일, 급여를 조회하기
SELECT EMP_ID,EMAIL, SALARY FROM EMPLOYEE;

--DEPARTMENT테이블 전체 조회하기
-- DEPARTMENT테이블 부서코드, 부서명 조회하기
SELECT*FROM DEPARTMENT;
SELECT DEPT_ID, DEPT_TITLE FROM DEPARTMENT;

-- DB에서는 SELECT무누 무언가 실행하고 결과를 가져올때 사용
-- SELECT문 함수실행, 산술연산도 함.
-- 기본연산이나 함수실행시에 SELECT문을 실행할때 테스트용 테이블을 제공->DUAL
--SELECT 컬럼
--FROM TABLE
SELECT*FROM DUAL;
--SELECT문을 이용해서 산술연산 처리하기
--1.리터럴값을 이용해서 산술연산 처리하기
SELECT 10+20 FROM DUAL;
SELECT 10+20,30*40, 4/5 FROM DUAL;
--2. 리터럴값과 컬럼을 산술연산하기
--산술연산을 하려면 기본적으로 연산자는 컬럼의 자료자 숫자형이어야함
SELECT*FROM EMPLOYEE;
-- SALARY에 1000을 넣어보자
SELECT SALARY, SALARY+1000 FROM EMPLOYEE;
SELECT EMP_NAME, EMP_NAME+100 FROM EMPLOYEE;
--3. 컬럼과 컬럼을 산술연산처리하기
SELECT SALARY, SALARY*BONUS FROM EMPLOYEE;
-- 컬럼값이 NULL인것과 연산을 하면 연산이 불가능하여 결과는 NULL을 출력한다

-- EMPLOYEE 테이블에서 리터럴끼리 연산하면?
SELECT EMP_NAME,10+20 FROM EMPLOYEE;

-- EMPLOYEE 테이블에서 각 사원의 연봉을 출력하기
-- 사원명, 급여, 연봉
SELECT EMP_NAME,SALARY,SALARY*12 FROM EMPLOYEE;
-- 사원명, 급여, 연봉, 보너스를 포함한 연봉 구하기
SELECT EMP_NAME, SALARY, SALARY*12, (SALARY+SALARY*BONUS)*12 FROM EMPLOYEE;

-- SELECT문에서 조회한 ㅓㄹ럼에대해 별칭을 부여할수있음
-- AS예약어를 이용해서 사용 가능
-- SELECT 컬럼명 AS 별칭,컬럼명 AS 별칭 FROM 테이블명
SELECT 10+20 AS 합 FROM DUAL;
SELECT EMP_NAME AS 사원명, EMP_NO AS 주민번호 FROM EMPLOYEE;
--별칭을 부여할때 AS는 생략도 가능
SELECT EMP_NAME 사원명, EMP_NO 주민번호, SALARY 월급 FROM EMPLOYEE;

--별칭을 부여할때 특수기호 사용이 가능한가?-> 가능 ""감싸줌
SELECT EMP_NAME "사 원 명", EMP_NO "주 민 번 호" FROM EMPLOYEE;

-- 조회 결과에서 중복값을 제거하는 명령어 : DISTINCT
SELECT DEPT_CODE FROM EMPLOYEE;
SELECT DISTINCT DEPT_CODE FROM EMPLOYEE;
--DISTINCT는 SELECT문의 맨앞에 나와야함
-- DISTINCT 뒤에 여러컬럼으ㅡㄹ 사용하면 여러컬럼이 모두 동일한 값을 중복으로 본다
SELECT DISTINCT DEPT_CODE, EMP_NAME FROM EMPLOYEE;


-- 문자열||컬럼을 연결해주는 연산자사용 : ||
--오라클에서 문자열 리터럴은 ''으로 표현
SELECT '안녕하세요','반갑습니다!' FROM DUAL;
SELECT '안녕하세요'||'반갑습니다!' AS 인사말 FROM DUAL;
SELECT EMP_NAME||'님 월급'|| SALARY||'원' AS MSG FROM EMPLOYEE;

-- ROW를 선택해서 조회하는 WHERE절 사용하기
-- WHERE절을 이용해서 원하는 데이터만 출력하기
-- SELECT*||컬럼명[,컬럼명....]
 -- FROM 테이블명
-- WHERE 조건문(비교연산, 논리연산)
SELECT*FROM EMPLOYEE;
-- 부서코드가 D5인 사원만 조회
SELECT*
FROM EMPLOYEE
WHERE DEPT_CODE='D5';

--EMPLOYEE 사원중 급여가 500만원 이상인 사원 구하기
SELECT*
FROM EMPLOYEE
WHERE SALARY>=5000000;


-- 사원중 직책이 J2 아닌 사원 구하기
SELECT *
FROM EMPLOYEE
WHERE JOB_CODE!='J2';--대소문자 구분해야함

-- EMPLOYEE 테이블에서 급여가 350만원 이상이고 부서코드가 D5인 사원을 조회
SELECT*
FROM EMPLOYEE
WHERE SALARY>=3500000 AND DEPT_CODE='D5';

--EMPLOYEE 테이블에서 급여가 350만원 이학거나 부서가 D5인 사원을 조회
SELECT*
FROM EMPLOYEE
WHERE SALARY<= 3500000 OR DEPT_CODE = 'D5';

-- 숫자의 범위를 조건으로 조회할때
-- AGE>=10&&AGE<30
-- 급여가 200만원이상 300만원 이하의 사원명, 이메일 급여를 조회하기
SELECT EMP_NAME, EMAIL, SALARY
FROM EMPLOYEE
WHERE SALARY>=2000000 AND SALARY<=3000000;
-- 날짜에 대한 비교연산이 가능
SELECT * FROM EMPLOYEE;
-- 00년 01월01일 이전에 입사한 사원조회
SELECT *
FROM EMPLOYEE
WHERE HIRE_DATE<'00/01/01';

-- 오라클에서 범위를 조회할때는 연산자를 만들어놨음
-- BETWEEN AND
SELECT EMP_NAME, EMAIL, SALARY
FROM EMPLOYEE
WHERE SALARY BETWEEN 2000000 AND 3000000;

-- 01년도에 입사한 사원을 조회
SELECT EMP_NAME, HIRE_DATE
FROM EMPLOYEE
WHERE HIRE_DATE BETWEEN '01/01/01' AND '01/12/31';

-- 01년도이외의 입사한 사원을 조회
SELECT EMP_NAME, HIRE_DATE
FROM EMPLOYEE
WHERE HIRE_DATE NOT BETWEEN '01/01/01' AND '01/12/31';

-- LIKE 연산자 이용하여 비교하기
-- LIKE : 문자열 패턴을 비교하는 연산자
-- % : 글자가 0개 이상 아무문자나 다 허용 예)'%강' -> 글자수 상관없이 강으로 끝나는 문자열
-- _ : 끌자가 1개 아무문자나 다 허용 예)'_강' 두글자이면서 강으로 끝나는 문자열
-- '%병&' -> 문자열 어디든 병 포함
-- '_병_' -> 세글자이면서 중간에 병
-- '__병%' -> 세글자 이상이면서 3번째글자 병
-- WHERE 컬럼명 LIKE '문자열패턴';
-- EMPLOYEE 테이블에서 유씨성을 가진 사원의 사원번호 사원명 급여를 조회하라
SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE
WHERE EMP_NAME LIKE '유%';

-- 이름 중간에 옹이 들어가는 사원의 사원번호, 사원명, 급여 조회
SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE
WHERE EMP_NAME LIKE '_옹%';

-- LIKE 부정문
-- NOT LIKE
-- 성이 유,김이 아닌 사원 조회하기
SELECT *
FROM EMPLOYEE
--WHERE EMP_NAME NOT LIKE '유%' AND EMP_NAME NOT LIKE '김%';
WHERE NOT (EMP_NAME LIKE '유%' AND EMP_NAME LIKE '김%');

--like절에서 패턴에서 사용하는 기호를 검색하고 싶을때
--이메일 주소의 _앞에 글자가 3글자인 사원의 사원번호, 사원명, 이메일, 급여조회
select *from employee;
select emp_id, emp_name, email, salary
from employee
--where email like '____%';
WHERE EMAIL LIKE'___#_%';


--null값을 조회하기
SELECT*FROM EMPLOYEE;
-- 사원중 DEPT_CODE가 NULL인 사원을 조회해보자
SELECT *
FROM EMPLOYEE
WHERE DEPT_CODE=NULL;
-- NULL은 의미없는 값, 쓰레기값! 연산 불가능
-- NULL값에 대한 비교연산은 따로 제공함
-- IS NULL->NULL인값 찾을때, IS NOT NULL->NULL이 아닌값 찾을때
SELECT *
FROM EMPLOYEE
WHERE DEPT_CODE IS NULL;

--보너스를 받는 사원의 사원번호, 사원명, 급여 보너스 조회하기
SELECT EMP_ID, EMP_NAME, SALARY, BONUS
FROM EMPLOYEE
WHERE BONUS IS NOT NULL;

--보너스를 받는 사원의 사원번호, 사원명, 급여, 보너스 보너스를 포함한 연봉 조회하기
--보너스를 포함한 연봉의 출력 컬럼명은 연봉으로 출력할것
SELECT EMP_ID, EMP_NAME, SALARY, BONUS, (SALARY+SALARY*BONUS)*12 AS 연봉
FROM EMPLOYEE
WHERE BONUS IS NOT NULL AND DEPT_CODE = 'D5';

-- 다중값을 비교하기
-- IN 비교연산자 ->여러개의 값을 동등비교하는 것으로, OR 연산과 연결된 것과 동일
-- 컬럼명 IN (값,값1,값2,...)== 컬럼명=값 OR 컬럼명=값1...
-- EMPLOYEE 테이블에서 부서코드가 D5나 D6인 사원의 사원명, 부서코드 조회하기
SELECT EMP_NAME, DEPT_CODE
FROM EMPLOYEE
WHERE DEPT_CODE IN ('D5','D6');
--IN은 나중에 배울 서브쿼리와 같이 많이 쓰임
--WHERE DEPR_CODE IN (SELECT DEPT_ID FROM DEPARTMENT WHERE DEPT_TITLE='해외영업1부' OR DEPT_TITLE='해외영업2부');

--NOT IN : 부정할때
--부서코드가 D5, D6이 아닌 사원의 전체 데이터 조회하기
SELECT *
FROM EMPLOYEE
WHERE DEPT_CODE NOT IN('D5','D6');

--직책이 J7, J2인 사원중 급여가 200만원 이상인 사원 조회하기
SELECT *
FROM EMPLOYEE
WHERE SALARY>=2000000 AND JOB_CODE IN('J7','J2');


-- 오라클이 제공하는 함수를 사용해보자
-- 크게 두가지로 나뉨
-- 1. 단일행함수 : 테이블에 있는 데이터(row)를 각각 실행해서 결과를 반환해주는 함수 -> ROW개수만큼 결과 반환
-- 2. 그룹함수 : 테이블에있는 데이터를 종합하여 한개의 결과를 반환해주는 함수

--단일행 함수에 대해 알아보자
--단일행 함수는 처리되는 타입에 따라 문자처리함수, 숫자처리 함수, 날짜처리함수로 나눌 수 있음
--SELECT 문의 컬럼작성위치, WHERE절 작성위치에 사용가능
--INSERT, UPDATE, DELETE 문에서도 사용가능

--문자열처리함수에 대해 알아보자
--LENGTH : 문자열의 길이를 출력해주는 함수
--LENGTH(컬럼명||'리터럴')
SELECT LENGTH('유병승') FROM DUAL;
SELECT '유병승', LENGTH('유병승') FROM DUAL;

--컬럼을 이용하기
SELECT EMP_NAME, LENGTH(EMP_NAME) FROM EMPLOYEE;
--EMPLOYEE테이블에서 사원의 이메일 글자수를 조회하기 사원명, 이메일,이메일 글자수
SELECT EMP_NAME, EMAIL, LENGTH(EMAIL)
FROM EMPLOYEE;

--WHERE 절에서 사용해보기
--EMAIL길이가 16이상인 사원의 사원명 이메일,이메일 글자수 출력하기
SELECT EMP_NAME, EMAIL, LENGTH(EMAIL)
FROM EMPLOYEE
WHERE LENGTH(EMAIL)>=16;

--INSTR
--찾는문자열이 지정한 위치부터 지정항 회수번째 나타나는 위치를 반노한하는 함수
--INSTR(문자열||컬럼명(대상),문자열||컬럼명(찾을문자)[,시작인덱스위치,몇번째])
SELECT INSTR('GD아카데미','GD')FROM DUAL;
--오라클에서 인덱스는 1부터 시작함
SELECT INSTR('GD아카데미 GD소프트웨어개발 GD경영','GD'),
        INSTR('GD아카데미 GD소프트웨어개발 GD경영','GD',3),
        INSTR('GD아카데미 GD소프트웨어개발 GD경영','GD',3,2),
        INSTR('GD아카데미 GD소프트웨어개발 GD경영','GD',-1,2)--음수는 오른쪽에서 시작
FROM DUAL;

--사원의 이메일에서 @의 위치를 찾아보자
SELECT EMAIL, INSTR(EMAIL,'@',1,2)
FROM EMPLOYEE;

SELECT EMP_NAME,EMAIL
FROM EMPLOYEE
WHERE INSTR(EMP_NAME,'유')=0;

--LPAD/RPAD : 공백에 특정문자를 추가해주는 함수
--LPAD('문자열'||컬럼명,차지할 길이,채울문자)
SELECT '유병승', LPAD('유병승',10,'*')
FROM DUAL;

--TRIM 쭉



-- 사원의 이메일에서 사이트명만 출력하기
--이메일 아이디@사이트주소
--아이디마나 출력
--사원명, 이메일, 사이트명||아이디
SELECT EMP_NAME, EMAIL, SUBSTR(EMAIL,INSTR(EMAIL,'@')+1),
SUBSTR(EMAIL,1,INSTR(EMAIL,'@')-1)
FROM EMPLOYEE;

--EMPLOYEE에서 성별이 여자인 사원을 구하기
SELECT * FROM EMPLOYEE;
SELECT*
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO,8,1) IN ('2','4');

--EMPLOYEE에서 이메일의 아이디가 5글자인 사원을 출력하기
SELECT *
FROM EMPLOYEE
WHERE LENGTH(SUBSTR(EMAIL,1,INSTR(EMAIL,'@')-1))=5;

--UPPER, LOWER INITCAP
SELECT UPPER('Welcome to oRACLEworld'),LOWER('Welcome to oRACLEworld'),
    INITCAP('Welcome to oRACLEworld')
    FROM DUAL;

--CONCAT:연결연산 문자열은 연결해주는 연산 ||
SELECT EMP_NAME, EMAIL, CONCAT(CONCAT(EMP_NAME,EMAIL),SALARY)
FROM EMPLOYEE;

--REPLACE : 대상문자에서 지정문자를 찾아 대체문자로 변경하는것
--REPLACE(대상문자||컬럼,지정문자,대체문자)
SELECT '나는 오라클을 싫어해',REPLACE('나는 오라클을 싫어해','싫어','좋아')
FROM DUAL;
--테이블에있는데이터가 변경되는 것은 아님.
--이베일주소를 BS->GD로 변경해라
SELECT EMAIL, REPLACE(EMAIL,'BS','GD')
FROM EMPLOYEE;

--REVERSE : 해당문자열을 역순으로 만드는것
SELECT 'ABCDE',REVERSE ('ABCDE')
FROM DUAL;

--TRANSLATE : 해당문자를 매칭되어있느느 문자로 출력해주는 기능
SELECT TRANSLATE('010-3644-6259','0123456789','영일이삼사오육칠팔구')
FROM DUAL;

--숫자처리함수
-- ABS : 절대값을 처리하는 함수
SELECT ABS(-10), ABS(10)
FROM DUAL;

--MOD : 나머지 값을 구하는 함수
SELECT MOD(3,2)
FROM DUAL;
SELECT SALARY,MOD(SALARY,3)
FROM EMPLOYEE
WHERE MOD(SALARY,3)=0;

--ROUND : 소숫점을 반올림하는 기능 (소수점숫자[,자리수])
--FLOOR : 소수점자리 버림
--TRUNC : 소수점자리 버림,자리수 지정가능
--CEIL : 무조건 올림

--날짜처리함수
--오라클에서 현재날짜를 출력할때는 SYSDATE예약어를 이용
SELECT SYSDATE
FROM DUAL;

--날짜에 숫자를 연산할 수 있다. +-연산가능
SELECT SYSDATE-1 AS 어제, SYSDATE+1 AS 내일
FROM DUAL;

-- NEXT_DAY: 매개변수로 받은 요일중 가장 가까운 다음일자를 표시
SELECT NEXT_DAY(SYSDATE, '화요일'), NEXT_DAY(SYSDATE, '금')
FROM DUAL;--로컬로 자동 번역된것

--LAST_DAY : 그달의 마지막날 출력
--ADD_MONTHS : 지정된 날에서 개월수를 더하는 계산
SELECT ADD_MONTHS(SYSDATE,3), ADD_MONTHS(SYSDATE,10)
FROM DUAL;

--EXTRACT : 날짜의 년, 월, 일울 따로 출력할수 있게 해주는 함수


--EMPLOYEE테이블에서 2월에 입사한 사원을 출력하기
-- 사원명, 입사일, 입사월
SELECT EMP_NAME, HIRE_DATE, EXTRACT(MONTH FROM HIRE_DATE)
FROM EMPLOYEE
WHERE EXTRACT(MONTH FROM HIRE_DATE)=2;
--90년대 입사한 사원 조회하기 사원명,월급,입사일
SELECT EMP_NAME, SALARY, HIRE_DATE, EXTRACT(MONTH FROM HIRE_DATE)
FROM EMPLOYEE
WHERE EXTRACT(YEAR FROM HIRE_DATE) BETWEEN 1990 AND 1999;

--오늘부로 이민규씨가 군대로 끌려가게 되었다.군복무기간은 1년6개월로하고
--전역일자를 구하고, 전역때까지 먹을 짬밥의 수를 구하세요(하루 3끼가정)
SELECT ADD_MONTHS(SYSDATE,18) AS 전역일, (ADD_MONTHS(SYSDATE,18)-SYSDATE)*3 AS 짬밥수
FROM DUAL;

-- 형변환함수 이용하기
-- 오라클은 자동형변환이 잘 작동함.. '년/월/일'
-- 오라클에서 주로 사용하는 자료형 숫자, 문자, 날짜
-- 숫자 : NUBER
-- 문자 : VARCHAR2,CHAR, NVARCHAR2, NCHAR * VARCAHR2사용해 권장이야!
-- 날짜 : DATE, TIMESTAMP
-- TO_CHAR : 숫자형, 날짜형을 문자형으로 변환해주는 함수
-- 날짜형을 문자형으로 변환하기
-- Y:년, M:월 D:일 H:시 MI:분 SS:초
SELECT TO_CHAR(SYSDATE,'YY-MM-DD HH24:MI:SS'), SYSDATE
FROM DUAL;
-- 숫자변환하기
-- 패턴에 맞춰서 변환 -> 숫자의 자리수에 대한 패턴
-- 0 : 변환하는값이 해당자리에 없으면 0으로 표시하고 있으면 그 숫자로 표현
-- 9 : 변환하는 값이 해당자리에 없으면 생략하고 있으면 그 숫자로 표현
-- 통화를 표시하고 싶을때는 패턴앞에 L표시를 하면됨.
SELECT 1234567, TO_CHAR(1234567,'999,999,999'),
    TO_CHAR(1234567,'000,000,000'), 
    TO_CHAR(1234567,'L999,999,999'),
    TO_CHAR(12334.67,'999,999.999'),
    TO_CHAR(12345,'999,999.99'),
    TO_CHAR(34.6,'999,999.99'),
    TO_CHAR(34.6,'000,999.00')
FROM DUAL;


--EMPLOYEE테이블의 급여를 이쁘게 표현해보자. 사원명, 급여
SELECT EMP_NAME, TO_CHAR(SALARY,'L999,999,999') AS 월급
FROM EMPLOYEE;

-- TO_DATE : 숫자, 문자를 날짜형으로 변환해주는 함수
-- 문자열패턴과 동일한 패턴을 사용
SELECT TO_DATE('22/04/10','YYYY/MM/DD'), TO_DATE('20220410','YYYYMMDD'),
    TO_DATE(20020505,'YYYYMMDD'), TO_DATE(981019,'YYMMDD'),
    TO_DATE(TO_CHAR(021019,'009999'),'YYMMDD')
FROM DUAL;

-- TO_NUMBER : 문자을 숫자로 변환해주는 함수 -> 산술계산을 위한.
SELECT '1,000,000', TO_NUMBER('1,000,000','999,999,999')+200000,
    TO_NUMBER('123A','999')
FROM DUAL;

-- NULL처리함수 NULL값을 특정값을 대체하는 기능
-- NVL(컬럼,대체값)
-- DEPT_CODE가 NULL이면 인턴으로 출력
SELECT EMP_NAME, NVL(DEPT_CODE,'인턴')
FROM EMPLOYEE;
-- BONUS가 NULL이면 0으로 출력하기
SELECT EMP_NAME, NVL(BONUS,0), (SALARY+SALARY*NVL(BONUS,0))*12 AS 연봉
FROM EMPLOYEE;

-- NVL2() : NULL일때, NULL이 아닐때 두가지 다 설정
SELECT * FROM EMPLOYEE;
SELECT EMP_NAME, MANAGER_ID, NVL2(MANAGER_ID,'있음','없음')
FROM EMPLOYEE;

-- 조건에 따라 분기해서 처리해주는 함수
-- 1. DECODE()
-- DECODE(대상이 되는값(문자||컬럼),동등비교값,동일할때처리할값,동등비교값2,동등할때처리할값2.....);
SELECT JOB_CODE,DECODE(JOB_CODE,'J1','대표','J2','부사장','J3','부장','J4','과장')
FROM EMPLOYEE;
-- EMPLOYEE테이블에서 성별을 확인해서 남자면 남, 여자면 여를 출력하기 사원명, 주민번호, 성별
SELECT EMP_NAME, EMP_NO, DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여') AS 성별
FROM EMPLOYEE;
--DECODE에서 DEFAULT값을 사용할 수 있음.
SELECT JOB_CODE,DECODE(JOB_CODE,'J1','대표','J2','부사장','J3','부장','J4','과장','미정')
FROM EMPLOYEE;

-- 2. CASE WHEN THEN
-- CASE 
--  WHEN 조건문(T) THEN 
--  WHEN 조건 THEN 
--  ELSE DEFAULT값
-- END
SELECT EMP_NAME, JOB_CODE,
    CASE
        WHEN JOB_CODE='J1' THEN '대표'
        WHEN JOB_CODE='J2' THEN '부사장'
        WHEN JOB_CODE='J3' THEN '부장'
        WHEN JOB_CODE='J4' THEN '과장'
        ELSE '미정'
    END AS 직책
FROM EMPLOYEE;    
SELECT EMP_NAME, JOB_CODE,
    CASE JOB_CODE
        WHEN 'J1' THEN '대표'
        WHEN 'J2' THEN '부사장'
        WHEN 'J3' THEN '부장'
        WHEN 'J4' THEN '과장'
        ELSE '미정'
    END AS 직책
FROM EMPLOYEE;

-- EMPLOYEE테이블에서 급여가 400만원이상이면 고액월급자, 300만원이상이면 중간월급자, 나머지는 슬프다
SELECT EMP_NAME, SALARY,JOB_CODE,
    CASE 
        WHEN SALARY>=4000000 THEN '고액월급자'
        WHEN SALARY>=3000000 THEN '중간월급자'
        ELSE '슬프다'
    END AS 비고
FROM EMPLOYEE;

-- YY RR표시 차이는?
-- 사원테이블에서 현재나이를 구하세요
SELECT EMP_ID, EMP_NAME,EMP_NO,
    EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM TO_DATE(SUBSTR(EMP_NO,1,2),'RR'))+1 AS 현재나이,
    EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM TO_DATE(SUBSTR(EMP_NO,1,2),'RR'))+1 AS RR,
    EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM TO_DATE(SUBSTR(EMP_NO,1,2),'YY'))+1 AS YY
FROM EMPLOYEE;
-- 두자리수로 년도를 표현했을때 -> 0000 YY RR했을때 앞에 붙는 세기가 다르기때문에 위 현상이 발생함.
-- 두자리를 YY로 표시를 하면 62 -> 2062 무조건 현 세기를 표시함
-- 1행  2020 - 2062 + 1-> -39
-- 2행  2020 - 2063 + 1 -> -40
-- 3행  2020 - 2086 + 1 -> -63

-- 년도 두자리를 RR로 받았을때
----------------------------------------------------------------------
--현재년도      입력년도      계산년도
----------------------------------------------------------------------
--00~49       00~49       현재세기
--00~49       50~99       전세기
--50~99       00~49       다음세기
--50~99       50~99       현재세기
--------------------------------------------------------------------
insert into EMPLOYEE (EMP_ID,EMP_NAME,EMP_NO,EMAIL,PHONE,DEPT_CODE,JOB_CODE,SAL_LEVEL,SALARY,BONUS,MANAGER_ID,HIRE_DATE, ENT_DATE,ENT_YN) 
values ('250','고두밋','470808-2123341','go_dm@kh.or.kr',null,'D2','J2','S5',4480000,null,null,to_date('94/01/20','RR/MM/DD'),null,'N');
COMMIT;

SELECT EXTRACT(YEAR FROM SYSDATE)
    -(TO_NUMBER(SUBSTR(EMP_NO,1,2))
                + CASE 
                    WHEN SUBSTR(EMP_NO,8,1) IN(1,2) THEN 1900
                    WHEN SUBSTR(EMP_NO,8,1) IN(3,4) THEN 2000 
                END) AS 정상나이
FROM EMPLOYEE;

--SELECT * FROM v$nls_parameters;

-- TO_DATE : 
-- TO_NUMBER : 

-- 그룹함수
-- 테이블의 데이터를 종합해서 하나의 ROW로 결과를 출력하는 함수
-- 통계를 내거나, 분석할때 많이 사용함.. 
-- 그룹함수는 집계하는 컬럼을 제외한 다른컬럼을 SELECT문에서 선택할 수 없음 
-- SUM : 데이터의 총 합계
-- AVG : 데이터의 평균값
-- COUNT : 데이터의 갯수==ROW의 갯수
-- 사원들의 급여의 총합계를 구하세요
SELECT * FROM EMPLOYEE;
SELECT SUM(SALARY) FROM EMPLOYEE;
SELECT EMP_NAME, SUM(SALARY) FROM EMPLOYEE;
--SELECT SUM(EMP_NAME) FROM EMPLOYEE;
--그룹함수에도 WHERE절은 사용이 가능함.
-- EMPLOYEE테이블에서 DEPT_CODE가 D5인사원의 급여 총합은?
 SELECT TO_CHAR(SUM(SALARY),'L999,999,999') 
 FROM EMPLOYEE 
 WHERE DEPT_CODE='D5';

--EMPLOYEE테이블에서 JOB_CODE가 J3인 사원의 급여합계는?
SELECT TO_CHAR(SUM(SALARY), 'L999,999,999')
FROM EMPLOYEE
WHERE JOB_CODE='J3';

-- AVG : 평균을 구하는 함수
-- 전체사원의 부서별 급여 평균은?
SELECT DEPT_CODE, TO_CHAR(TRUNC(AVG(SALARY),-1),'L999,999,999') AS 급여평균
FROM EMPLOYEE
GROUP BY DEPT_CODE;

-- D6부서의 급여평균을 구하세요!
SELECT AVG(SALARY)
FROM EMPLOYEE
WHERE DEPT_CODE='D6';

-- SUM, AVG함수를 활용할때 컴럼에 NULL값이 있다면 어떻게 될까? -> NULL값은 갯수에서 제외
SELECT SUM(BONUS) AS 합계, AVG(NVL(BONUS,0)) AS 평균
FROM EMPLOYEE;
--WHERE BONUS IS NOT NULL;

-- COUNT : RESULTSET의 ROW의 갯수(=DATA의 수)를 출력해주는 함수
-- 전체사원의 수를 구하기
SELECT COUNT(*) FROM EMPLOYEE;
-- COUNT함수의 매개변수에는  *, 컬럼명이 들어갈 수 있음
-- * : 무조건 전체 ROW를 다 계산함. 컬럼에 하나라도 값이 있으면 NULL이 아니면 계산함.
-- 컬럼명 : 그 컬럼에 NULL인것은 제외하고 계산을 함.
SELECT COUNT(*), COUNT(BONUS) FROM EMPLOYEE;

-- 급여를 400만원보다 많이 받고있는 사원의 수
SELECT COUNT(*)
FROM EMPLOYEE
WHERE SALARY>=4000000;

SELECT * FROM EMPLOYEE WHERE SALARY BETWEEN 2000000 AND 4000000;

-- 부서가 D9인 사원의 수
SELECT COUNT(*) 
FROM EMPLOYEE
WHERE DEPT_CODE='D9';

-- 부서가 D6이거나 D5이거나 D7인 사원의 수, 급여평균, 급여합계를 조회하세요
SELECT COUNT(*), SUM(SALARY), AVG(SALARY)
FROM EMPLOYEE
WHERE DEPT_CODE IN ('D6','D5','D7');

-- MIN/MAX : 최소값 / 최대값
SELECT MIN(SALARY), MAX(SALARY) FROM EMPLOYEE;

-- SELECT문에서 데이터를 정렬하는 방법
-- 데이터 정렬을 하려면 ORDER BY 절을 사용함
-- SELECT
-- FROM
-- [WHERE ]
-- [ORDER BY 컬럼명 정렬방법(오름(ASC,DEFAULT), 내림(DESC)]
SELECT EMP_NAME, EMAIL, SALARY 
FROM EMPLOYEE
ORDER BY SALARY;
-- 급여가 높은순으로 정렬하기
SELECT EMP_NAME, EMAIL, SALARY
FROM EMPLOYEE
ORDER BY SALARY DESC;

-- 이름 순으로 내림차순정렬
SELECT EMP_NAME, SALARY
FROM EMPLOYEE
--ORDER BY EMP_NAME;
ORDER BY EMP_NAME DESC;

-- ORDER BY 절에서는 SELECT문에서 사용한 별칭을 사용할수도 있다.
SELECT EMP_NAME AS 사원, SALARY 월급
FROM EMPLOYEE
--WHERE 월급>=3000000;-- WHERE절에서는 별칭사용이 불가능함.!
ORDER BY 월급 DESC;

--ORDER BY 절에서는 인덱스를 활용할 수 있음
--RESULTSET의 컬럼에는 인덱스번호가 부여됨, 1번부터....
SELECT * FROM EMPLOYEE;
SELECT EMP_NAME, SALARY, DEPT_CODE, JOB_CODE
FROM EMPLOYEE
ORDER BY 2 DESC;

SELECT EMP_NAME, SALARY, DEPT_CODE
FROM EMPLOYEE
WHERE DEPT_CODE IN ('D5','D6','D9')
ORDER BY 2 DESC;

-- 정렬할때 기준을 여러컬럼을 설정할 수 있음
SELECT EMP_NAME, DEPT_CODE, JOB_CODE
FROM EMPLOYEE
ORDER BY DEPT_CODE DESC, JOB_CODE;

-- 정렬시에 NULL값처리
-- 기본적으로 ASC = 맨밑으로, DESC =맨위로 처리
SELECT EMP_NAME, BONUS
FROM EMPLOYEE
ORDER BY BONUS ASC NULLS FIRST;
--ORDER BY BONUS DESC NULLS LAST;

-- GROUP BY / HAVING
SELECT * FROM EMPLOYEE;
SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE
ORDER BY 1;

--직책별 인원수를 구해보자.
SELECT JOB_CODE, COUNT(*)
FROM EMPLOYEE
GROUP BY JOB_CODE
ORDER BY JOB_CODE;

--부서별 300만원 이상 받는 사원 수
SELECT DEPT_CODE, JOB_CODE, COUNT(*)
FROM EMPLOYEE
--WHERE SALARY>=3000000
GROUP BY DEPT_CODE, JOB_CODE;
-- GROUP BY 절에는 한개이상의 컬럼도 가능

--부서별 사원수가 3명이상인 부서만 출력하기
SELECT DEPT_CODE, COUNT(*)
FROM EMPLOYEE
--WHERE COUNT(*)>=3--그룹함수 WHERE절 사용불가
GROUP BY DEPT_CODE
--그룹함수의 결과를 조건으로 사용하고 싶을때 HAVING 사용
HAVING COUNT(*)>=3;

--매니저가 관리하는 사원이 2명이상인 매니저 출력하기
SELECT MANAGER_ID, COUNT(*)
FROM EMPLOYEE
WHERE MANAGER_ID IS NOT NULL
GROUP BY MANAGER_ID
HAVING COUNT(*)>=
ORDER BY 1;--맨 뒤에

--부서 평균이 400만원 이상인 부서 조합













-- 집합연산자
-- 두개이상의 SELECT 문을 합쳐주는 연산자
-- UNION : 두개이상의 SELECT문을 합쳐주는 연산 * 중복값을 한개표시
-- UNION ALL : 두개 이상의 SELECT문을 합쳐주는 연산 * 중복값을 모두 표시
-- INTERSECT : 두개 이상의 SELECT문에서 중복되는 값만 보ㅕㅇ주는 연산
-- MINUS : 두개 이상의 SELECT문에서 기준 SELECT문에서 다른 SELECT문의 결과를 뺀 나머지만 보여주는 연산 * 중복제거

















-- JOIN : 여러 테이블을 특정 컬럼값을 기준으로 합쳐서 한대 테이블로 사용하게 하는것
-- JOIN구문은 오라클 전용구문, ANSI표준
-- 오라클 전용구문
SELECT * 
FROM EMPLOYEE,DEPARTMENT
WHERE DEPT_CODE=DEPT_ID;

SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;
--ANSI표준을 이용해서 JOIN문 활용하기
SELECT *
FROM EMPLOYEE
    JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID);
    
-- 사원의 사원명, 이메일, 부서명, 급여 조회하고 싶다
SELECT EMP_NAME, EMAIL, DEPT_TITLE, SALARY
FROM EMPLOYEE
    JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID);--연관된 데이터
    
-- 사원의 사원 아이디, 사원명, 직책명, 이메일 조회해보자
SELECT EMP_ID, EMP_NAME, JOB_NAME, EMAIL
--FROM EMPLOYEE E JOIN JOB J ON E.JOB_CODE=J.JOB_CODE;--겹칠때 별칭부여
FROM EMPLOYEE JOIN JOB USING(JOB_CODE);


--INNER JOIN : 동등비교했을때 일치하는 값이 없는 ROW생략
SELECT COUNT(*)
FROM EMPLOYEE JOIN DEPARTMENT ON (DEPT_CODE=DEPT_ID);

--JOIN WHERE, GROUP BY ~ HAVING ORDER BY 구문을 사용할 수 있음
--부서가 총무부인 사원의 사원명, 부서코드, 부서명, 급여를 조회
SELECT EMP_NAME, DEPT_CODE, DEPT_TITLE, SALARY
FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
WHERE DEPT_TITLE='총무부';
-- 직책이 과장, 부장인 사원의 사원명, 이메일, 직책명, 부서코드, 월급 조회
SELECT EMP_NAME, EMAIL, JOB_CODE, DEPT_CODE, SALARY
FROM EMPLOYEE JOIN JOB USING(JOB_CODE)
WHERE JOB_NAME IN ('과장','부장');

--SELECT *, 컬럼 사용하려면 반드시 별칭이 필요함
SELECT E.*, JOB_NAME, J.JOB_CODE
FROM EMPLOYEE E JOIN JOB J ON(E.JOB_CODE=J.JOB_CODE);

--부서별 사원수 조회하기 부서명, 사원수
SELECT DEPT_TITLE, COUNT(*)
FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
GROUP BY DEPT_TITLE
HAVING COUNT(*)>3--추가로 해보는 거
ORDER BY 2, DEPT_TITLE;
--SELECT *
--FROM EMPLOYEE JOIN DEPARTMENT  ON DEPT_CODE=DEPT_ID;




--OUTERJOIN: 특정 테이블을 기준으로 연결되는 값이 없으며녀 NULL 출력하고/ 데이터 전체를 출력하는것
SELECT NVL(DEPT_TITLE,'미지정'), COUNT(*)
FROM EMPLOYEE LEFT JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID--LEFT 왼쪽을 기준으로
GROUP BY DEPT_TITLE
ORDER BY 2, DEPT_TITLE;

--오라클 전용구문
SELECT * --COUNT(*) 있을때,없을때
FROM EMPLOYEE,DEPARTMENT
WHERE DEPT_CODE=DEPT_ID(+);--플러스가 아닌거 기준
--ANSI표준
SELECT *
FROM EMPLOYEE RIGHT OUTER JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID;--L/R 기준자

--CROSS JOIN : 카티션 곱


--다중조인 : 두개 이상의 테이블을 합치는 것
--사원의 사원명, 직책명, 부서명을 조회하기
SELECT EMP_NAME, DEPT_TITLE, JOB_NAME
FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
JOIN JOB USING(JOB_CODE);


--사원의 사원명, 부서명, 직책명, 근무지역 조회하기 *부서가 없으면 대기, 근무지역이 NULL인 사람은 대리발령으로 출력
SELECT EMP_NAME, NVL(DEPT_TITLE, '대기'), JOB_NAME, NVL(LOCAL_NAME, '대기발령')
FROM EMPLOYEE
    LEFT JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
    JOIN JOB USING(JOB_CODE)
    LEFT JOIN LOCATION ON LOCATION_ID=LOCAL_CODE;

-- 근무지가 ASIA1 지역인 사원의 사원명, 부서명, 직책명, 근무지 조회
SELECT EMP_NAME, DEPT_TITLE, JOB_NAME, LOCAL_NAME
FROM EMPLOYEE
    LEFT JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
    JOIN JOB USING(JOB_CODE)
    LEFT JOIN LOCATION ON LOCATION_ID=LOCAL_CODE--COLUMN 여부에 따라 순서 달라짐
WHERE LOCAL_NAME='ASIA1';

--근무지별 사원 수 조회하기
SELECT LOCAL_NAME, COUNT(*)
FROM EMPLOYEE
    LEFT JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
    LEFT JOIN LOCATION ON LOCAL_CODE=LOCATION_ID
GROUP BY LOCAL_NAME;

-- SELF JOIN : 테이블 한개를 가지고 조인을 만드는 것 -> 자기 테이블을 자신 것과 연결하는 것
-- SELF JOIN 테이블에 같은 값을 갖는 컬럼이 두개 있어야함.
SELECT * FROM EMPLOYEE;
-- 각 사원의 매니저 이름을 조회하자
SELECT E.EMP_ID, E.EMP_NAME, M.EMP_NAME, M.EMP_ID
FROM EMPLOYEE E LEFT JOIN EMPLOYEE M ON E.MANAGER_ID=M.EMP_ID;


-- 동등 비교를 해서 테이블 JOIN
-- 대소비교를 통해서 테이블 JOIN 방법 -> NON-EQU JOIN
SELECT * FROM SAL_GRADE;

SELECT EMP_NAME, SALARY, SG.SAL_LEVEL
FROM EMPLOYEE
    JOIN SAL_GRADE SG ON SALARY BETWEEN MIN_SAL AND MAX_SAL;
    --회원등급 포인트제로, 제품 상태

-- 서브쿼리 : SELECT문 안에 또다른 SELECT문을 사용한 구문
-- 서브쿼리를 사용할때는 반드시 괄호로 묶어 줘야함.
-- 전지연사원의 매니저이름 출력하기
SELECT MANAGER_ID FROM EMPLOYEE WHERE EMP_NAME='전지연';
SELECT EMP_NAME FROM EMPLOYEE WHERE EMP_ID=214;
SELECT EMP_NAME
FROM EMPLOYEE
WHERE EMP_ID=(SELECT MANAGER_ID FROM EMPLOYEE WHERE EMP_NAME='전지연');

-- 윤은해 사우너과 동일한 급여를 받고있는 사원을 조회
-- 사원명, 급여 조회
SELECT EMP_NAME, SALARY
FROM EMPLOYEE
WHERE EMP_NAME!='윤은해' AND SALARY=(SELECT SALARY FROM EMPLOYEE WHERE EMP_NAME='윤은해');

--그룹함수 이용해서 처리하는 것도 ㅗ가능
SELECT AVG(SALARY)
FROM EMPLOYEE;
-- 전체 사원의 급여 평균보다 많은 급여를 받고있는 사원출력
-- 사원 ID, 사원명, 급여
SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE
WHERE SALARY>(SELECT AVG(SALARY) FROM EMPLOYEE);

-- 부서명이 총무부인 사원을 조회하기 사원명, 이메일, 급여
--JOIN <- 이 좀 더 괜찮으느 코드
SELECT EMP_NAME, EMAIL, SALARY
FROM EMPLOYEE LEFT JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
WHERE DEPT_TITLE='총무부';
--서브쿼리
SELECT EMP_NAME, EMAIL, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE=(SELECT DEPT_ID FROM DEPARTMENT WHERE DEPT_TITLE='총무부');

--다중형 서브쿼리 : 서브쿼리의 결과가 여러 ROW를 가질때..
-- 서브쿼리의 결과 행이 다수이기때문에 <=,>=,<,>,= 불가능함
-- 동등비교 : IN, 대소 : ANY, ALL
-- 송중기, 박나라와 같은 부서에서 일하는 사원의 사원명, 부서코드 조회
SELECT EMP_NAME, DEPT_CODE
FROM EMPLOYEE
WHERE DEPT_CODE IN (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME IN ('송종기','박나라'));

-- 직급이 부사장, 부장이 아닌 사원을 모두 출력하기
SELECT *
FROM EMPLOYEE
WHERE JOB_CODE NOT IN (SELECT JOB_CODE FROM JOB WHERE JOB_NAME  IN ('부사장','부장'));

--서브쿼리에서도 JOIN을 사용할 수 있다
--ASIA1에서 근무하는 직원을 조회하기
SELECT *
FROM EMPLOYEE
WHERE DEPT_CODE IN (SELECT DEPT_ID
                    FROM DEPARTMENT
                    JOIN LOCATION ON LOCATION_ID=LOCAL_CODE
                    WHERE LOCAL_NAME='ASIA1');
-- 대소비교
-- ANY : 그 값 중에서 하나가 참이면 참-> ROW를 OR로 연결하고 비교
-- 컬럼>(=) ANY(다중행서브쿼리문 값1, 값2) : 컬럼이 값1, 값2 중 하나라도  크면 참-> 서브쿼리의 최소값보다 크면 참
-- 컬럼<(=) ANY(다중행서브쿼리문 값1, 값2) : 컬럼이 값1, 값2 중 하나라도  작으면 참-> 서브쿼리의 최대값보다 작으면 참

-- D5, D6부서의 사원 월급의 최대값보다 작은 사원들 조회하기
SELECT EMP_NAME, SALARY
FROM EMPLOYEE
WHERE SALARY< ANY (SELECT SALARY FROM EMPLOYEE WHERE DEPT_CODE IN('D5','D6'));

-- D5, D6부서의 사원 월급의 최소값보다 큰 사원들 조회하기
SELECT EMP_NAME, SALARY
FROM EMPLOYEE
--WHERE SALARY> ANY (SELECT SALARY FROM EMPLOYEE WHERE DEPT_CODE IN('D5','D6'));
WHERE SALARY> (SELECT MIN(SALARY) FROM EMPLOYEE WHERE DEPT_CODE IN('D5','D6'));



-- ALL : 다중값을 AND 연결
-- 컬럼 > ALL(서브쿼리값1, 값2) : 컬럼이 값1,값2 중 최대값 보다 크면 참
-- 컬럼 < ALL(서브쿼리값1, 값2) : 컬럼이 값1,값2 중 최소값 보다 작으면 참

--D2 부서의 사원들의 급여의 최대 급여보다 많이 받는 사원
SELECT EMP_NAME, SALARY
FROM EMPLOYEE
WHERE SALARY > ALL(SELECT SALARY FROM EMPLOYEE WHERE DEPT_CODE='D2');

--D2 부서의 사원들의 급여 최소값보다 적게받는 사원
SELECT EMP_NAME, SALARY
FROM EMPLOYEE
WHERE SALARY < ALL(SELECT SALARY FROM EMPLOYEE WHERE DEPT_CODE='D2');

--2000년 1월 1일 이전 입사자 중 200-년 1월 1일 후 입사한 사원보다 급여를 (가장 높게 받는 사원보다) 높게받는 사원의 사원명, 급여조회
SELECT EMP_NAME, SALARY
FROM EMPLOYEE
WHERE HIRE_DATE < '00/01/01'
    AND SALARY > ALL (SELECT SALARY FROM EMPLOYEE WHERE HIRE_DATE >'00/01/01');


-- 다중열서브쿼리 : 서브쿼리의 결과가 컬럼이 여러개인 서브쿼리
-- 퇴직한 사원과 부서, 직책이 같은 사원을 조회하기
SELECT DEPT_CODE, JOB_CODE FROM EMPLOYEE WHERE ENT_YN='Y';
SELECT EMP_NAME, DEPT_CODE, JOB_CODE
FROM EMPLOYEE
--WHERE DEPT_CODE =(SELECT DEPT_CODE FROM EMPLOYEE WHERE ENT_YN='Y')
--AND JOB_CODE=(SELECT JOB_CODE FROM EMPLOYEE WHERE ENT_YN='Y');
WHERE (DEPT_CODE, JOB_CODE)=(SELECT DEPT_CODE, JOB_CODE FROM EMPLOYEE WHERE ENT_YN='Y');

--기술지원부 이면서 급여가 200만원인 사원이 있다.
-- 그 사원의 전체정보를 조회해보자
SELECT * FROM EMPLOYEE
WHERE (DEPT_CODE,SALARY)=(SELECT DEPT_CODE, SALARY
                            FROM EMPLOYEE LEFT JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
                            WHERE DEPT_TITLE='기술지원부' AND SALARY= 2000000);
                            
-- 다중행 다중열 쿼리 행도 여러개, 열도 여러개
-- 부서별 최소급여를 아는 어떤 사원해보자
SELECT DEPT_CODE, MIN(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE;

SELECT *
FROM EMPLOYEE
WHERE (DEPT_CODE, SALARY) IN (SELECT DEPT_CODE, MIN(SALARY)
                                FROM EMPLOYEE
                                GROUP BY DEPT_CODE);
                                
--직책별 가장 높은 급여를 받는 사원 조회하기
SELECT *
FROM EMPLOYEE
WHERE (JOB_CODE, SALARY) IN (SELECT JOB_CODE, MAX(SALARY)
                                FROM EMPLOYEE
                                GROUP BY JOB_CODE);

-- 상관서브쿼리 : 주쿼리에 데이터가 서브쿼리의 출력결과에 영향을 주고 서브쿼리 결과가 다시 주 쿼리 결과에 영향을 주는 쿼리문
--부하직원이 있는 ㄴ사원을 조회
SELECT *
FROM EMPLOYEE
WHERE EMP_ID IN (SELECT MANAGER_ID FROM EMPLOYEE);

-- EXISTS 연산자 -> RESULT SET의 결과가 1행 이상이면 TRUE, 0행이면 FALSE 상관서브쿼리 사용할때 많이 사용
SELECT *
FROM EMPLOYEE E
WHERE EXISTS(SELECT EMP_NAME FROM EMPLOYEE WHERE E.EMP_ID=MANAGER_ID);

-- 심봉선 사원과 같은 부서의 사원의 부서코드, 사원명을 조회
SELECT DEPT_CODE, EMP_NAME
FROM EMPLOYEE E
--WHERE DEPT_CODE=(SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME='심봉선');
WHERE EXISTS (SELECT * FROM EMPLOYEE WHERE E.DEPT_CODE=DEPT_CODE AND EMP_NAME='심봉선');

--스칼라서브쿼리 : 상관서브쿼리면서 결과가 한행만 나오는 서브쿼리
-- 각 사원 자신이 속한 부서의 평균 급여를 사원명, 부서코드, 직책코드, 급여와 같이 출력
SELECT EMP_NAME, DEPT_CODE, JOB_CODE, SALARY, (SELECT AVG(SALARY) FROM EMPLOYEE WHERE E.DEPT_CODE=DEPT_CODE) AS 부서평균급여
FROM EMPLOYEE E;

-- 자신이 속한 부서의 사원수 구하기 사원명, 부서코드, 사원수
SELECT EMP_NAME, NVL(DEPT_CODE,'INTERN'), (SELECT COUNT(*) FROM EMPLOYEE WHERE NVL(E.DEPT_CODE,'INTERN')=NVL(DEPT_CODE,'INTERN'))AS 부서인원수
FROM EMPLOYEE E;

-- 자신이 속한 부서의 평균급여보다 많이 받은 직원의 이름, 부서코드,급여 조회하기
SELECT EMP_NAME,DEPT_CODE,SALARY
FROM EMPLOYEE E
WHERE SALARY>(SELECT AVG(SALARY) FROM EMPLOYEE WHERE E.DEPT_CODE=DEPT_CODE);

-- 자신이 속한 직급의 평균보다 적게받는 직원의 이름, 직책명, 급여를 조회
SELECT EMP_NAME, JOB_NAME, SALARY
FROM EMPLOYEE E JOIN JOB J ON(E.JOB_CODE=J.JOB_CODE)--USING 쓰면 식별자 사용 불가
WHERE SALARY<(SELECT AVG(SALARY) FROM EMPLOYEE WHERE E.JOB_CODE=JOB_CODE);


-- 인라인뷰 : FROM 절ㄹ에 서브쿼리 (다중행, 다중열)를 사용하는 것
-- 인라인뷰 : 1회용으로 SELECT문의 결과를 테이블로 사용하는 것
-- STORED뷰 : FROM절에 사용하는 SELECT문 저장해서 사용할 것->VIEW

--EMPLOYEE 테이블에 성별을 추가해서 테이블형식으로 만들때
SELECT EMP_NAME, DEPT_CODE, DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여') AS 성별
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO,8,1)='1';

SELECT * --JOB_CODE,SALARY 서브쿼리에 없어서 불가능
FROM (SELECT EMP_NAME, DEPT_CODE, DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여') AS 성별
    FROM EMPLOYEE)
WHERE 성별='남';


--JOIN, 집합연산자를 사용한 쿼리문에대해 인라인뷰로 활용
SELECT EMP_NAME, DEPT_TITLE, JOB_NAME
FROM (SELECT * FROM EMPLOYEE LEFT JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID JOIN JOB USING (JOB_CODE))
WHERE DEPT_TITLE='총무부';

--AHT
--1. 로우넘 컬럼 이용하는 방법-> 오라클에서 제공하는 컬럼
--데이터에 번호를 부여한 컬럼 셀렉문 실행할때마다 로우넘 컬럼 생성 됨
SELECT ROWNUM, EMP_NAME,SALARY FROM EMPLOYEE;
SELECT EMP_NAME, SALARY
FROM EMPLOYEE
WHERE ROWNUM BETWEEN 1 AND 3;

--급여를 제일 적게 받는 사원 탑3 조회하기 사원명,부서코드, 직책코드, 급여
SELECT ROWNUM,EMP_ID, EMP_NAME, DEPT_CODE, JOB_CODE, SALARY
FROM EMPLOYEE
--WHERE ROWNUM BETWEEN 1 AND 3
ORDER BY SALARY;

--정렬한 순서대로 번호를 부여하려면 인라인뷰를 이용해야한다
SELECT ROWNUM,E.*
FROM (SELECT * FROM EMPLOYEE ORDER BY SALARY) E
WHERE ROWNUM BETWEEN 1 AND 3;

--급여를 많이 받는 사원 5등~10등까지 출력하기 이름, 급여
--ROWNUM은 가상컬럼으로 1부터 시작하면 WHERE에 사용해서 조회가능
--사용하기 위해서는 지정된 ROWNUM을 한번더 인라인뷰 처리를 해야함
SELECT *
FROM ( SELECT ROWNUM AS RNUM, E.*--EMP_NAME, SALARY
        FROM (SELECT * 
            FROM EMPLOYEE ORDER BY SALARY DESC)E)
WHERE RNUM BETWEEN 5 AND 10;--1부터는 되는데 다른 숫자는 안 됨

-- 급여를 많이 받는 TOP 10조회하기
SELECT ROWNUM,E.*
FROM (SELECT * FROM EMPLOYEE ORDER BY SALARY desc) E
WHERE ROWNUM BETWEEN 1 AND 10;
-- D5에서 연봉을 많이 받는 사람 3명 조회하기


--2. 오라클이 제공하는 WINDOW함수 이용방법
SELECT *
FROM (
    SELECT EMP_NAME, SALARY, RANK() OVER(ORDER BY SALARY DESC)AS 순위
    FROM EMPLOYEE)
WHERE 순위 BETWEEN 1 AND 3;

-- DENSE_RANK() OVER() : 동일값이 있는 경우 순위 매기는 방식이 다름
SELECT EMP_NAME, SALARY, DENSE_RANK() OVER(ORDER BY SALARY DESC) AS 순위
FROM EMPLOYEE;

-- 계층형쿼리문 -오라클에서 제공하는 기능
-- ROW를 연결관게에 따라서 조합하여 출력하는 기능
SELECT LEVEL, EMP_ID, EMP_NAME, MANAGER_ID
FROM EMPLOYEE
START WITH EMP_ID=200 --최상위계층
CONNECT BY PRIOR EMP_ID=MANAGER_ID;

SELECT LEVEL||' '||LPAD(' ',(LEVEL-1)*5,' ')||EMP_NAME AS 조직도
FROM EMPLOYEE
START WITH EMP_ID=200
CONNECT BY PRIOR EMP_ID=MANAGER_ID; --댓글 대댓글쓸때 사용가능


--오라클에서 사용하는 데이터형 알아보기
--문자형 : VARCHAR2, CHAR, NCHAR, NVARCHAR2, CLOB--+ LONG
-- CHAR() : 저장공간 고정으로 설정, 고정형 타입 최대 2000타입
-- VARCHAR(20) : 들어온 데이터를 기준으로 저장공간 할당. 가변형 타입 최대 4000바이트까지 저장가능
CREATE TABLE TBL_DATA_STR(
    A CHAR(6),
    B VARCHAR2(6),--BYTE 크기
    C NCHAR(6),
    D NVARCHAR2(6)
);
SELECT * FROM TBL_DATA_STR;
INSERT INTO TBL_DATA_STR VALUES ('ABC','ABC','ABC','ABC');
INSERT INTO TBL_DATA_STR VALUES ('가나','가','가나다','가나');
INSERT INTO TBL_DATA_STR VALUES ('가나','가나','가나다라','가다다라');
SELECT LENGTH(A),LENGTH(B),LENGTH(C),LENGTH(D)
FROM TBL_DATA_STR;

CREATE TABLE TBL DATA_STR2
 A CHAR(2000)
 B VARCHAR2(4000)
 C LONG
 D CLOB
);

SELECT * FROM TBL_DATA_STR2;

 
-- 숫자형 : NUMBER 실수, 정수 모두 저장이 가능함
-- NUMBER[(PRECISION,SCALE)]
-- PRECISION : 표현할수 있는 전체 자리수(1~38)
-- SCALE : 소수접자리표현(-84~127)
CREATE TABLE TBL_DATA_NUM(
    A NUMBER,
    B NUMBER(5),
    C NUMBER(5,1),
    D NUMBER(5,-2)
);

SELECT * FROM TBL_DATA_NUM;
INSERT INTO TBL_DATA_NUM VALUES(1234.567, 1234.567,1234.567,1234.567);
INSERT INTO TBL_DATA_NUM VALUES(1234.567, 1234.567,12340.567,1234.567);

-- 날짜형 : DATE
CREATE TABLE TBL_DATA_DATE(
    BIRTHDAY DATE,
    TEST1 TIMESTAMP
);
SELECT * FROM TBL_DATA_DATE;
INSERT INTO TBL_DATA_DATE VALUES('96/10/28');
INSERT INTO TBL_DATA_DATE VALUES(TO_DATE('199610281034','YYYYMMDDHHMI'));

-- 기본테이블 생성해보자
-- CREATE TABLE명령어로 테이블을 생성할 수 있다.
-- CREATE TABLE 테이블명(각 컬럼지정)
CREATE TABLE MEMBER(
    MEMBER_ID VARCHAR2(20),
    MEMBER_PWD VARCHAR2(10),
    MEMBER_AGE NUMBER,
    ENROLL_DATE DATE
);
SELECT* FROM MEMBER;
DESC MEMBER;

--생성된 테이블의 컬럼에 COMMENT달기
COMMENT ON COLUMN MEMBER.MEMBER_ID IS '회원아이디';
COMMENT ON COLUMN MEMBER.MEMBER_PWD IS '회원비밀번호';
COMMENT ON COLUMN MEMBER.MEMBER_AGE IS '';

--컬럼의 COMMENT확인하는 명령어
SELECT * FROM USER_COL_COMMENTS
WHERE TABLE_NAME='MEMBER';

-- 테이블 생성시 각 컬럼, 테이블에 제약조건 설정하기
-- NOTNULL (C) : 특정 컬럼에 NULL값을 허용하지 않는것 -> 모든 컬럼은 DEFAULT로 NULL값을 허용함
-- UNIQUE (U) : 특정 컬럼에 중복값을 허용하지않는 것
-- PRIMARY KEY (P) : 데이터를 구분하는 컬럼에 지정하는 제약조건으로 UNIQUE, NOT NULL 제약조건이 자동설정,
--                  일반적으로 테이블의 1개 컬럼에 설정 * 1개이상의 컬럼으로 지정할 수 있음 -> 복합키
-- FOREIGN KEY (R) : 특정 컬럼의 값음 다른테이블에 지정된 컬럼의 값을 가져와 사용해야하는 것 * 다른 테이블 지정컬럼은 중복값이 있으면 안 됨
-- CHECK (C) : 특정 컬럼의 값을 지정된 값만 저장하게하는 것, 특정 문구, 특정 범위를 설정

-- 제약조건을 조회하는 SELECT문
SELECT *
FROM USER_CONSTRAINTS;
-- 제약조건이 설정된 컬럼을 확인하는 SELECT문
SELECT * 
FROM USER_CONS_COLUMNS;
-- 통상 제약조건 검색할때는 USER_CONSTRAINTS테이블, USER_CONS_COLUMNS테이블 JOIN해서 활용
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, COLUMN_NAME
FROM USER_CONSTRAINTS JOIN USER_CONS_COLUMNS USING(CONSTRAINT_NAME);

--NOT NULL 제약조건 활용하기
CREATE TABLE MEMBER_N(
USER_NO NUMBER,
USER_ID VARCHAR2(20),
USER_PWD VARCHAR2(20),
USER_NAME VARCHAR2(20)
);
SELECT * FROM MEMBER_N;
INSERT INTO MEMBER_N VALUES (1,'ADMIN','1234','관리자');
INSERT INTO MEMBER_N VALUES (1,'ADMIN','1234',NULL);
INSERT INTO MEMBER_N VALUES (NULL,NULL,NULL,NULL);

--제약조건 설정하는 방법
--1. 컬럼 레벨에서 설정 -> CREATE TABLE 문에서 컼ㄹ럼을 선언하는 부분에 제약조건을 설정
--2. TABLE레벨에서 설정 -> CREATE TABLE 문에서 컬럼설정이 끝나고 마지막에 제약조건을 설정

-- 테이블의 특정컬럼에 NOT NULL 설정하기
--컬럼레벨에서만 설저엉이 가능한 제약조건
DROP TABLE MEMBER_NN;
CREATE TABLE MEMBER_NN(
USER_NO NUMBER,
USER_ID VARCHAR2(20) CONSTRAINT USER_ID_NN NOT NULL,
USER_PWD VARCHAR2(20) NOT NULL,
USER_NAME VARCHAR2(20)
);

SELECT * FROM MEMBER_NN;
INSERT INTO MEMBER_NN VALUES (1,'ADMIN','1234','관리자');
INSERT INTO MEMBER_NN VALUES (1,NULL,NULL,'유저');--불가능
INSERT INTO MEMBER_NN VALUES (1,'USER',NULL,'유저');--불가능
INSERT INTO MEMBER_NN VALUES (NULL,'TEST','TEST',NULL);
UPDATE MEMBER_NN SET USER_ID=NULL WHERE USER_ID='ADMIN';

-- UNIQUE : 중복값은 저장하지 못하게 하는 것
-- 컬럼레벨, 테이블레벨 둘다 설정가능
CREATE TABLE MEMBER_UQ(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) NOT NULL,   
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(20)
);
INSERT INTO MEMBER_NN VALUES(1,'TEST','TEST','테스트');
INSERT INTO MEMBER_NN VALUES(1,'TEST1','TEST1','테스트1');
SELECT * FROM MEMBER_UQ;
INSERT INTO MEMBER_UQ VALUES(1,'TEST','TEST','테스트');
INSERT INTO MEMBER_UQ VALUES(2,'TEST1','TEST1','테스트1');
--UNIQUE제약 조건에서 NULL 값은 어떻게 처리되나?
INSERT INTO MEMBER_UQ VALUES(NULL,'TEST3','TEST3','테스트3');
INSERT INTO MEMBER_UQ VALUES(NULL,'TEST4','TEST4','테스트4');

CREAT TABLE MEMBER_UQ2(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) NOT NULL,   
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(20),
    --테이블 레벨에서 제약조건 설정하기
    CONSTRAINT USER_NO_UQ UNIQUE(USER_NO)
    --UNIQUE(USER_NO)
);
SELECT * FROM MEMBER_UQ2;
INSERT INTO MEMBER_UQ2 VALUES(1,'TEST','TEST','테스트');
INSERT INTO MEMBER_UQ2 VALUES(2,'TEST1','TEST1','테스트1');

-- UNIQUE 제약 조건은 다수 컬럼을 묶어서 지정할 수 있음
CREATE TABLE MEMBER_UQ3(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) NOT NULL,   
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(20),
    UNIQUE(USER_NO,USER_ID)
  --  UNIQUE(USER_NO),--위에는 동시에 만족할때만
  --  UNIQUE(USER_ID)--
);
INSERT INTO MEMBER_UQ3 VALUES(1,'TEST','TEST','테스트');
INSERT INTO MEMBER_UQ3 VALUES(2,'TEST1','TEST1','테스트1');
INSERT INTO MEMBER_UQ3 VALUES(2,'TEST2','TEST2','테스트2');--삽입 됨
INSERT INTO MEMBER_UQ3 VALUES(2,'TEST1','TEST3','테스트3');-- 안 됨
SELECT * FROM MEMBER_UQ3;

-- PRIMARY KEY : RLQHSRL PK
-- 테이블의 각 데이터를 구분할 수 있는 값에 지정-> 중복값이 없고, NULL이 없어야함
-- PRIMARY KEY 제약조건을 설정하면 자동으로 UNIQU, NOTNULL 제약조건이 설정됨
-- 한개 테이블당 하나의 PK만 설정가능
--테이블레벨, 컬럼 레벨에서 설정가능
CREATE TABLE MEMBER_PK(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE NOT NULL,  --필요한 제약조건 적기만하기
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(20),
    USER_AGE NUMBER,
    EMAIL VARCHAR2(50)
    --,CONSTRAINT USER_NO_PK PRIMARY KEY(USER_MO) 도 가능
);
INSERT INTO MEMBER_PK VALUES(1,'ADMIN','1234','관리자',20,'TEST@TEST.COM');
INSERT INTO MEMBER_PK VALUES(2,'USER01','1234','유저',30,'TEST1@TEST1.COM');
INSERT INTO MEMBER_PK VALUES(3,'USER02','1234','유저2',30,'TEST2@TEST2.COM');
INSERT INTO MEMBER_PK VALUES(4,'USER03','1234','유저',30,'TEST3@TEST3.COM');
SELECT * FROM MEMBER_PK;
--USERNO PK
SELECT * FROM MEMBER_PK WHERE USER_NAME='유저';

--PRIMARY KEY는 여러개의 컬럼을 묶어서 설저어 ->복합키
CREATE TABLE TBL_ORDER(
    PRODUCT_NO NUMBER,
    ORDER_NO NUMBER,
    COUNT NUMBER,
    ORDER_DATE DATE,
    PRIMARY KEY(ORDER_NO, PRODUCT_NO, ORDER_DATE)
    );
INSERT INTO TBL_ORDER VALUES(1,1,10,'22/04/15');
INSERT INTO TBL_ORDER VALUES(2,1,5,'22/04/15');
INSERT INTO TBL_ORDER VALUES(3,2,20,'22/04/15');
INSERT INTO TBL_ORDER VALUES(1,1,50,'22/04/05');
INSERT INTO TBL_ORDER VALUES(1,NULL,50,'22/04/05');--불가능
SELECT * FROM TBL_ORDER;

-- FOREGIGN KEY 외래키
-- 다른 테이블에있는 값을 가져와 사용하는 것
-- 부모 자식관계로 설정

CREATE TABLE PRODUCT(
    PRO_NO NUMBER PRIMARY KEY,
    PRO_NAME VARCHAR2(20) NOT NULL,
    PRICE NUMBER,
    TYPE VARCHAR(10) NOT NULL
);
INSERT INTO PRODUCT VALUES(1,'스타일러',180,'의류');
INSERT INTO PRODUCT VALUES(2,'포르쉐',10000,'자동차');
INSERT INTO PRODUCT VALUES(3,'반포자이',60000,'주택');
SELECT * FROM PRODUCT;

CREATE TABLE PRO_BUY(
    BUY_NO NUMBER PRIMARY KEY,
    BUY_DATE DATE NOT NULL,
    PRO_NO NUMBER REFERENCES PRODUCT(PRO_NO)
);
SELECT * FROM PRO_BUY;
SELECT * FROM PRODUCT;
INSERT INTO PRO_BUY VALUES(1,SYSDATE,1);
INSERT INTO PRO_BUY VALUES(2,SYSDATE,2);
INSERT INTO PRO_BUY VALUES(3,SYSDATE,3);
INSERT INTO PRO_BUY VALUES(4,SYSDATE,1);

SELECT * FROM PRO_BUY JOIN PRODUCT USING(PRO_NO);

--외래키로 설정한 컬럼은 함부로 삭제할 수가 없다!
SELECT * FROM PRO_BUY;
SELECT * FROM PRODUCT;
DELETE FROM PRODUCT WHERE PRO_NO=2;
DELETE FROM PRO_BUY WHERE PRO_NO=2;

--외래키 설정시 주의할점 참조된느 컬럼은 반드시 UNIQUE, PK 제약조건이 설정 돼야함
DROP TABLE TEST1;
CREATE TABLE TEST1(
    FKTEST VARCHAR2(10) UNIQUE,
    FKNAME VARCHAR2(20)
);
CREATE TABLE TEST2(
    FNO NUMBER,
    FKTEST VARCHAR2(10) REFERENCES TEST1(FKTEST) NOT NULL
);
--참조값에 NULL 들어갈수 있을까?
INSERT INTO TEST1 VALUES('안녕','하이');
INSERT INTO TEST2 VALUES(1,'안녕');
INSERT INTO TEST2 VALUES(2,'하이');
INSERT INTO TEST2 VALUES(2,NULL);

SELECT * FROM TEST2;

CREATE TABLE PRODUCT1(
    PRO_NO NUMBER PRIMARY KEY,
    PRO_NAME VARCHAR2(20) NOT NULL,
    PRICE NUMBER,
    TYPE VARCHAR(10) NOT NULL
);
INSERT INTO PRODUCT1 VALUES(1,'스타일러',180,'의류');
INSERT INTO PRODUCT1 VALUES(2,'포르쉐',10000,'자동차');
INSERT INTO PRODUCT1 VALUES(3,'반포자이',60000,'주택');

CREATE TABLE PRO_BUY1(
    BUY_NO NUMBER PRIMARY KEY,
    BUY_DATE DATE NOT NULL,
    PRO_NO NUMBER REFERENCES PRODUCT(PRO_NO),
    USER_NO NUMBER,
    --부모키 삭제에 대한 옵션설정 가능
    --FOREIGN KEY(USER_NO) REFERENCES MEMBER_PK(USER_NO) ON DELETE SET NULL
    FOREIGN KEY(USER_NO) REFERENCES MEMBER_PK(USER_NO) ON DELETE CASCADE
);
DROP TABLE PRO_BUY1;
SELECT * FROM MEMBER_PK;
INSERT INTO PRO_BUY1 VALUES(1,SYSDATE,1,4);
INSERT INTO PRO_BUY1 VALUES(2,SYSDATE,1,2);
INSERT INTO PRO_BUY1 VALUES(3,SYSDATE,3,3);
INSERT INTO PRO_BUY1 VALUES(4,SYSDATE,1,4);
SELECT * FROM PRO_BUY1;
DELETE FROM MEMBER_PK WHERE USER_NO=2;

CREATE TABLE PRODUCT2(
    PNO NUMBER PRIMARY KEY,
    PNAME VARCHAR2(20) NOT NULL
);
SELECT * FROM PRODUCT2;
INSERT INTO PRODUCT2 VALUES(1, '스타일러');
INSERT INTO PRODUCT2 VALUES(2, '포르쉐');
INSERT INTO PRODUCT2 VALUES(3, '반포자이');
INSERT INTO PRODUCT2 VALUES(4, '노트북');
CREATE TABLE HIS_BUY(
    HIS_NO NUMBER PRIMARY KEY,
    --PNO NUMBER REFERENCES PRODUCT2(PNO) ON DELETE SET NULL--부모 삭제 자식O
    PNO NUMBER REFERENCES PRODUCT2(PNO) ON DELETE CASCADE--부모 삭제 자식X
);
SELECT * FROM BUY;
INSERT INTO HIS_BUY VALUES(1,1);
INSERT INTO HIS_BUY VALUES(2,2);
INSERT INTO HIS_BUY VALUES(3,3);
INSERT INTO HIS_BUY VALUES(4,4);
DELETE FROM PRODUCT2 WHERE PNO=1;
DROP TABLE HIS_BUY;

--CHECK 제약조건
CREATE TABLE USER_CHECK(
    USER_NO NUMBER PRIMARY KEY,
    USER_NAME VARCHAR2(20),
    GENDER VARCHAR2(5) CHECK(GENDER IN ('남','여')),
    AGE NUMBER,
    GRADE VARCHAR2(20) CHECK(GRADE IN ('실버','골드','플레티넘')),
    CHECK(AGE>19 AND USER_NO>0)
);
INSERT INTO USER_CHECK VALUES(1,'김도영','여','32','플레티넘');
INSERT INTO USER_CHECK VALUES(2,'김도영','F','32','플레티넘');
INSERT INTO USER_CHECK VALUES(3,'김도영','여','19','플레티넘');

CREATE TABLE TEST_MEMBER(
    MEMBER_CODE NUMBER,
    MEMBER_ID VARCHAR2(20), --중복금지
    MEMBER_PWD CHAR(20) NOT NULL, 
    MEMBER_NAME NCHAR(10) UNIQUE,
    MEMBER_ADDR CHAR(50) NOT NULL,
    GENDER VARCHAR2(5) CHECK(GENDER IN ('남','여')),
    PHONE VARCHAR2(20) NOT NULL
);
SELECT * FROM TEST_MEMBER;
INSERT INTO TEST_MEMBER();


--서브쿼리를 이용해서 기존테이블 복사해서 테이블 생성하기
CREATE TABLE EMP_COPY
AS SELECT*FROM EMPLOYEE;
SELECT * FROM EMP_COPY;

CREATE TABLE EMP_ALL
AS SELECT * FROM EMPLOYEE LEFT JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
JOIN JOB USING (JOB_CODE);
SELECT * FROM EMP_ALL;
-- 데이터를 제외하고 서브쿼리를 이용해서 테이블 만들기
CREATE TABLE EMP_ALL_EMPTY
AS SELECT * 
    FROM EMPLOYEE
    LEFT JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
    JOIN JOB USING (JOB_CODE)
    WHERE 100=1;

SELECT * FROM EMP_ALL_EMPTY;


--DML활용하기
-- INSERT : 데이터를 테이블에 삽입하는 명령어
-- 한번에 한개의 데이터만 삽입,
--1. 컬럼을 지정해서 데이터를 삽입하는 방법
--  지정되지 않ㅇ으 ㄴ컬럼에 데이터는 NULL값이 자동 대입 * 컬럼에 NOT NULL 제약조건이 있으면 안 돼
--INSERT INTO 테이블(컬럼명,컬럼명2,컬럼명3...) VALUES (값,값1,값2,...)
--2. 전체컬럼을 다 대입하는 방법
--INSERT INTO 테이블명 VALUES(컬럼개수만큼, 로 구분해서 값을 넣는다);
SELECT * FROM DEPARTMENT;
INSERT INTO DEPARTMENT(DEPT_ID, DEPT_TITLE) VALUES ('D0','기술개발부');--골라서 할경우 NOT NULL도 감안해야함
INSERT INTO DEPARTMENT(DEPT_ID, LOCATION_ID) VALUES ('D0','L3');
INSERT INTO DEPARTMENT VALUES ('A0','기술개발부','L4');

-- EMPLOYEE 테이블에 본인정보 삽입하기
SELECT *FROM EMPLOYEE;
INSERT INTO EMPLOYEE VALUES (777,'이종석','930903-1111111','뭐해','DJ','AA','SS','SS',999999999,1,NULL,NULL,NULL,NULL);

-- 서브쿼리를 이요해서 INSERT하기 데이터복사 삽입
CREATE TABLE INSERT_TEST
AS SELECT EMP_ID, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID WHERE 1=0;

SELECT * FROM INSERT_TEST;
INSERT INTO INSERT_TEST VALUES ('999','유병승','자바연구부');
INSERT INTO INSERT_TEST(SELECT EMP_ID, EMP_NAME, DEPT_TITLE
                                FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
                                WHERE DEPT_CODE='D6');
                                
INSERT INTO INSERT_TEST(EMP_ID, EMP_NAME)(SELECT EMP_ID, EMP_NAME FROM EMPLOYEE WHERE DEPT_CODE='D5');

-- INSERT ALL : 두개 이상의 테이블에 값을 넣을때 사용
-- 한개의 쿼리문으로 가져와 데이터를 두개의 테이블에 각각 넣을때
CREATE TABLE EMP_HIRE_DATE
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE FROM EMPLOYEE WHERE 1=0;
CREATE TABLE EMP_MANAGER
AS SELECT EMP_ID, EMP_NAME, MANAGER_ID FROM EMPLOYEE WHERE 1=0;

SELECT * FROM EMP_HIRE_DATE;
SELECT * FROM EMP_MANAGER;

INSERT ALL
INTO EMP_HIRE_DATE VALUES(EMP_ID, EMP_NAME, HIRE_DATE)
INTO EMP_MANAGER VALUES(EMP_ID, EMP_NAME, MANAGER_ID)
SELECT EMP_ID, EMP_NAME, MANAGER_ID, HIRE_DATE
FROM EMPLOYEE;

--INSERT ALL을 조건에 따라 데이터 넣기
CREATE TABLE EMP_OLD
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE FROM EMPLOYEE WHERE 1=0;
CREATE TABLE EMP_NEW
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE FROM EMPLOYEE WHERE 1=0;

SELECT * FROM EMP_OLD;
SELECT * FROM EMP_NEW;

INSERT ALL
WHEN HIRE_DATE<'00/01/01' THEN INTO EMP_OLD VALUES(EMP_ID,EMP_NAME,HIRE_DATE)
WHEN HIRE_DATE>'00/01/01' THEN INTO EMP_NEW VALUES(EMP_ID,EMP_NAME,HIRE_DATE)
SELECT EMP_ID, EMP_NAME, HIRE_DATE FROM EMPLOYEE;
SELECT *FROM EMP_OLD;
SELECT * FROM EMP_NEW;

-- UPDATE : ROW의 특정컬럼의 데이터를 수정
-- UPDATE 테이블명 SET 컬럼명=수정값[, 컬럼명=수정값, 컬럼명=수정값 ...] WHERE 조건
CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT;
SELECT * FROM DEPT_COPY;
UPDATE DEPT_COPY SET DEPT_TITLE='자바연구부' WHERE_ID='D0';
ROLLBACK;

--여러 컬럼을 변경 가능
UPDATE DEPT_COPY SET DEPT_TITLE='집가기부', LOCATION_ID='L9' WHERE DEPT_ID='A0';
--여러 행을 변경 가능
UPDATE DEPT_COPY SET DEPT_TITLE=DEPT_TITLE||'추가' WHERE DEPT_TITLE LIKE '해외%';

-- UPDATE에서 서브쿼리 이용하기
CREATE TABLE EMP_SALARY
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, JOB_CODE, SALARY, BONUS
FROM EMPLOYEE;
SELECT* FROM EMP_SALARY;

--방명수의 급여, 보너스를 심봉선의 데이터랑 동일하게 수정해라 //연동이 아님?
--심봉선의 데이터 먼저 가져오기
SELECT SALARY, BONUS FROM EMPLOYEE WHERE EMP_NAME='심봉선';
SELECT*FROM EMPLOYEE WHERE EMP_NAME='방명수';
UPDATE EMPLOYEE SET SALARY=3500000,BONUS=0.15 WHERE EMP_NAME='방명수';
ROLLBACK;
--EMP_SALARY에서 하이유의 SALARY, BONUS를 400만, BONUS 2.5로 수정하기
UPDATE EMP_SALARY SET SALARY=4000000, BONUS=2.5 WHERE EMP_NAME='하이유';

--연동시키기
UPDATE EMP_SALARY SET (SALARY,BONUS)=(SELECT SALARY, BONUS FROM EMP_SALARY WHERE EMP_NAME='심봉선')
WHERE EMP_NAME='방명수';
SELECT *FROM EMPLOYEE WHERE EMP_NAME='방명수';

-- EMP_SALARY 테이블에서 임시환 사원의 직급을 과장, 부서를 해외 영업 3부로 변경하기 //코드명 이용해서 고정으로 변경할 수도 있다
UPDATE EMP_SALARY
SET JOB_CODE=(SELECT JOB_CODE FROM JOB WHERE JOB_NAME='과장'),
    DEPT_CODE=(SELECT DEPT_CODE FROM DEPARTMENT WHERE DEPT_TITLE='해외영업3부')
WHERE EMP_NAME='임시환';
-- 더 가독성 좋게>>>>
UPDATE EMP_SALARY
SET (DEPT_CODE, JOB_CODE)=(SELECT DEPT_ID, JOB_CODE FROM DEPARTMENT CROSS JOIN JOB--크로스조인하면 다 챙겨오는 것 가능
                            WHERE JOB_NAME='과장' AND DEPT_TITLE='해외영업3부')
WHERE EMP_NAME='임시환';
SELECT * FROM EMP_SALARY WHERE EMP_NAME='임시환';         


--DELETE : 조건에 해당하는 데이터를 삭제하는 명령어
-- DELETE FROM 테이블명 WHERE 조건식
-- WHERE 안 적으면 테이블의 전체 ROW가 삭제
SELECT * FROM EMP_SALARY;
DELETE FROM EMP_SALARY;
ROLLBACK;

--보너스를 받지 않는 사원을 삭제하기
DELETE FROM EMP_SALARY WHERE BONUS IS NULL;
SELECT * FROM EMP_SALARY;

--삭제시 주의할점, 외래키 제약조건이 있는 ROW를 삭제할때에는 DELECT옵션이 있거나, 참조하고있는 다른 테이블의
--데이터를 삭제후 삭제를 해야한다,

--TRUNCATE : DELETE와 동일한 ROW삭제->삭제후 오토커밋 ROLLBACK사용 불가능
SELECT * FROM EMP_SALARY;
TRUNCATE TABLE EMP_SALARY;

-- MERGE : 구조가 동일한 테이블 합치기
CREATE TABLE TBL_MERGE01(
    ID VARCHAR2(20),
    NAME VARCHAR2(20)
);
CREATE TABLE TBL_MERGE02(
    ID VARCHAR2(20),
    NAME VARCHAR2(20)
);
SELECT * FROM TBL_MERGE01;
SELECT * FROM TBL_MERGE02;

INSERT INTO TBL_MERGE01 VALUES('USER01', 'USER01');
INSERT INTO TBL_MERGE01 VALUES('USER02', 'USER02');
INSERT INTO TBL_MERGE01 VALUES('USER03', 'USER03');
INSERT INTO TBL_MERGE02 VALUES('USER04', 'USER04');
INSERT INTO TBL_MERGE02 VALUES('USER02', '유저2');
INSERT INTO TBL_MERGE02 VALUES('USER03', '유저3');

SELECT * FROM TBL_MERGE01;
SELECT * FROM TBL_MERGE02;

MERGE INTO TBL_MERGE01
USING TBL_MERGE02 ON (TBL_MERGE01.ID=TBL_MERGE02.ID)--기준 같은 것
WHEN MATCHED THEN
UPDATE SET TBL_MERGE01.NAME=TBL_MERGE02.NAME
WHEN NOT MATCHED THEN
INSERT VALUES(TBL_MERGE02.ID, TBL_MERGE02.NAME);

SELECT * FROM TBL_MERGE01;


--DDL (ALTER, DROP) 활용하기
-- ALTER TABLE : TABLE에 정의 되어있는 내용을 수정할때 사용하는 명ㄹ령어
--컬럼추가, 컬럼삭제, 컬럼 TYPE 변경, 컬럼 TYPE의 길이변경, 제약조건 추가수정삭제
--컬럼명 테이블명, 제약조건명 변경
CREATE TABLE TBL_USERALTER(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(20)
);
SELECT * FROM TBL_USERALTER;

--생성된 테이블에 컬럼 추가하기
ALTER TABLE TBL_USERALTER
ADD (USER_NAME VARCHAR2(20));
DESC TBL_USERALTER;

INSERT INTO TBL_USERALTER VALUES(1,'ADMIN','1234','관리자');

-- 기존에 데이터가 있는 테이블에 컬럼을 추가할때 봐야할것
ALTER TABLE TBL_USERALTER
ADD (EMAIL VARCHAR2(30));
SELECT * FROM TBL_USERALTER;
DELETE FROM TBL_USERALTER;

ALTER TABLE TBL_USERALTER
ADD(NICKNAME VARCHAR2(20) NOT NULL);
-- DEFAULT를 설정하면 추가되는 컬럼에 NOT NULL제약조건을 설정할 ㅏ수 있다.
DROP TABLE TBL_USERALTER;
CREATE TABLE TBL_USERALTER(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(20)
);
INSERT INTO TBL_USERALTER VALUES(1, 'USER01','USER01');
SELECT * FROM TBL_USERALTER;
ALTER TABLE TBL_USERALTER
ADD (EMAIL VARCHAR2(30) DEFAULT '미설정' NOT NULL);
INSERT INTO TBL_USERALTER VALUES(2,'USER02','USER02',DEFAULT);
SELECT * FROM TBL_USERALTER;

--ALTER로 제약조건 추가하기
ALTER TABLE TBL_USERALTER
ADD CONSTRAINT USER_NO_PK PRIMARY KEY(USER_NO);

ALTER TABLE TBL_USERALTER
ADD UNIQUE(USER_ID);

--제약조건명 수정하기
ALTER TABLE TBL_USERALTER
RENAME CONSTRAINT SYS_C007401 TO TBL_USERALTER_USER_ID_UQ;
--컬럼명 변경하기
ALTER TABLE TBL_USERALTER
RENAME COLUMN EMAIL TO USER_EMAIL;

SELECT * FROM TBL_USERALTER;
-- 컬럼을 수정하기 -> 컬럼의 타입변경하거나, 타입의 크기를 변경할때 사용
-- MODIFY 예약어 이용
ALTER TABLE TBL_USERALTER
MODIFY USER_PWD VARCHAR2(100);--길이 변경
-- 수정시 주의할점 테이블 내에 데이터가 있는 경우 수정하는 길이가 데이터보다 작으면 안 된다.

-- 제약조건 수정
--NOT NULL 제약조건 설정하기
--ALTER TABLE TBL_USERALTER
--ADD CONSTRAINT USER_PWD_NN NOT NULL;--ADD로 설정하지 않음, 추가가 아닌 수정을 해야함
ALTER TABLE TBL_USERALTER
MODIFY USER_PWD CONSTRAINT USER_PWD_NN NOT NULL;

-- 컬럼 삭제하기
--DROP
ALTER TABLE TBL_USERALTER
DROP COLUMN USER_EMAIL;
SELECT * FROM TBL_USERALTER;

ALTER TABLE TBL_USERALTER
DROP CONSTRAINT USER_PWD_NN;

-- 테이블 이름 변경하기
ALTER TABLE TBL_USERALTER RENAME TO CHANGE_TABLE;
SELECT * FROM TBL_USERALTER;
SELECT * FROM CHANGE_TABLE;
RENAME CHANGE_TABLE TO TBL_USERALTER;

-- 테이블 삭제하기
--DROP TABLE 테이블명
DROP TABLE TBL_USERALTER;
--테이블에 참조관계가 있을때는 지울수 없다.

CREATE TABLE TBL_FKTEST(
    EMP_ID VARCHAR2(20) CONSTRAINT FK_EMP_ID REFERENCES EMPLOYEE(EMP_ID),
    CONTENT VARCHAR2(30)
);

SELECT * FROM TBL_FKTEST;
INSERT INTO TBL_FKTEST VALUES(200,'TEST1');
INSERT INTO TBL_FKTEST VALUES(201,'TEST2');
INSERT INTO TBL_FKTEST VALUES(202,'TEST3');
INSERT INTO TBL_FKTEST VALUES(203,'TEST4');
--INSERT INTO TBL_FKTEST VALUES(444,'TEST4'); 안 된다
--DROP TABLE EMPLOYEE CASCADE CONSTRAINT;--삭제 되지 않음// CASCADE 쓰면 다 삭제됨


--DCL : DATA CONTROL LANGGUAGE
--데이터 제어 언어, DB에 대한 보안, 무결성, 복구 등 DBMS를 제어하기 위한 언어
-- 권한 관련, 트렌젝션처리 관련내용이 있음
--권한관련 GRANT, REVOKE
--GRANT 권한[,권한 ,권한 ,...] | ROLE() TO 사용자계정
--QWER/QWER ->생성하기 DBA에서 하기
alter session set "_ORACLE_SCRIPT"=true;
CREATE USER QWER IDENTIFIED BY QWER default tablespace users quota unlimited on users;
GRANT CONNECT TO QWER;
GRANT RESOURCE TO QWER;
--QWER 접속으로 명령어 실행하기
SELECT * FROM TAB;
CREATE TABLE TEST1(
    T1 VARCHAR2(20),
    T2 NUMBER
);
--RESOURCE ROLE에 권한 확인하기
SELECT * FROM DBA_SYS_PRIVS WHERE GRANTEE='RESOURCE';
SELECT * FROM DBA_SYS_PRIVS WHERE GRANTEE='CONNECT';

SELECT * FROM BS.EMPLOYTEST;
SELECT * FROM QWER.TEST1;
SELECT * FROM BS.EMPLOYEE;

--다른 계정의 테이블도 권한이 부여되면 부여된 권한만큼 테이블을 이용할 수 있다.
GRANT SELECT ON BS.EMPLOYEE TO QWER;
SELECT * FROM BS.EMPLOYEE;

--QWER계정에 BS계정의DEPARTMENT테이블을 조회할수 있도록 해보자
GRANT SELECT ON BS.DEPARTMENT TO QWER;
SELECT * FROM BS.DEPARTMENT;
INSERT INTO BS.DEPARTMENT VALUES('A1','날씨좋다','L6');
UPDATE BS.DEPARTMENT SET DEPT_TITLE='날씨좋다' WHERE DEPT_ID='D0';
GRANT INSERT, UPDATE ON BS.DEPARTMENT TO QWER;

-- 권한 회수하기
-- REBOKE 권한| ROLE FROM 사용자명|| ROLE
REVOKE SELECT ON BS.EMPLOYEE FROM QWER;

SELECT * FROM BS.EMPLOYEE;

--ROLE 만들기
CREATE ROLE MYROLE;
GRANT CREATE TABLE, CREATE VIEW TO MYROLE;
SELECT * FROM DBA_SYS_PRIVS WHERE GRANTEE='MYROLE';

--트렌젝션 : 하나의 작업단위를 의미함 서비스의 작업단위
-- COMMIT : 작업단위를 확정짓고 데이터베이스에 저장하는 것
-- ROLLBACK : 작업단위에 에러가 발생되어 실행됐던 모든 내용을 원상태로 되돌리는 것
-- DML : INSERT, UPDATE, DELETE 구문에서만 발생한다.
INSERT INTO JOB VALUES('J0','백수');
SELECT * FROM JOB;
COMMIT;

-- 트렌젝션의 범위는 SESSION이 연결되고 DML 구문을 시작하고 COMMIT을 한 시점부터 다음 COMMIT||ROLLBACK 시점까지
UPDATE JOB SET JOB_NAME='쉬시' WHERE JOB_CODE='J0';
SELECT * FROM JOB;
ROLLBACK;

INSERT INTO JOB VALUES('K0','KK');
UPDATE JOB SET JOB_NAME='쉬시' WHERE JOB_CODE='J0';

SELECT * FROM JOB;
ROLLBACK;

-- VIEW  : STORED VIEW를 의미함(여기서는)
-- SELECT 문의 결과인 RESULT SET을 하나의 테이블처럼 활용하도록 함
CREATE VIEW V_EMP_DEPT
AS SELECT * FROM EMPLOYEE LEFT JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID;
GRANT CREATE VIEW TO BS;

SELECT * FROM V_EMP_DEPT;--반영구적으로 사용 가능한가?

--각 분야별 평균 월급 조회
-- 부서별 평균, 직책별 평균, 총 평균
SELECT DEPT_CODE, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_CODE;
SELECT JOB_CODE, AVG(SALARY) FROM EMPLOYEE GROUP BY JOB_CODE;
SELECT AVG(SALARY) FROM EMPLOYEE;

CREATE VIEW TBL_AVGSALARY
AS SELECT DEPT_CODE AS DIVIDE, AVG(SALARY) AS AVG_SAL FROM EMPLOYEE GROUP BY DEPT_CODE --컬럼의 별명과 함께 지정해야함
UNION
SELECT JOB_CODE, AVG(SALARY) FROM EMPLOYEE GROUP BY JOB_CODE
UNION
SELECT '전체 평균', AVG(SALARY) FROM EMPLOYEE;

SELECT * FROM TBL_AVGSALARY;
SELECT * FROM TBL_AVGSALARY; WHERE DIVIDE LIKE 'D%';

--VIEW에서 DML구문을 사용할 수 있는가?
-- INSERT, UPDATE, DELETE 구문-> 실제 물리적인 테이블의 데이터가 수정->VIEW테이블의 컬럼과 실제 테이블의 컬럼이 매칭되면 수정가능
SELECT *FROM V_EMP_DEPT;
UPDATE V_EMP_DEPT SET EMP_NAME='문석원' WHERE EMP_NAME='하이유';
SELECT * FROM V_EMP_DEPT;
SELECT * FROM EMPLOYEE;
-- 가상의 컬럼은 수정이 불가능
UPDATE TBL_AVGSALARY SET AVG=2000000 WHERE DIVIDE LIKE 'D%';--집계함수는 직접적 연결이 없어서 부적합

-- INSERT 명령실행하기
-- 단일 테이블과 연결된 VIEW는 가능, 단 VIEW로 생성된 컬럼이회에 물리적인 테이블의 컬럼의 제약조건이 NOT NULL이면 안 됨!
CREATE VIEW V_EMPTEST
AS SELECT EMP_ID, EMP_NO, EMP_NAME, EMAIL, PHONE,JOB_CODE, SAL_LEVEL FROM EMPLOYEE;
SELECT * FROM V_EMPTEST;
INSERT INTO V_EMPTEST VALUES('998','991026-1234567','박선우','SUN@SUN.COM','01012345678','J0','S2');
SELECT * FROM EMPLOYEE;
-- JOIN문으로 연결된 VIEW는 불가능함.
INSERT INTO V_EMP_DEPT VALUES('999','이민규','961028-1234567','MIN@MIN.COM','01023456789','D5','J2','S2',100,NULL,
'201',SYSDATE,NULL,'N','00','민규부서','L5');--불가능

-- DELETE문은 사용가능할까?
DELETE FROM V_EMPTEST WHERE EMP_NAME='박선우';
SELECT * FROM V_EMPTEST;
DELETE FROM V_EMP_DEPT WHERE EMP_NAME='고두밋'; --사용가능 INSERT만 제약

--DML구문이 불가능한경우
--1. 뷰에서 정의하고 있지 않은 컬럼을 수정하는 경우
SELECT * FROM V_EMPTEST;
UPDATE V_EMPTEST SET SALARY=1234;--없다
--2. 뷰에 포함되지않은 컬럼중 실제 테이블 제약조건에 NOT NULL이 있는 경우
--3. 산술연산으로 구성되니 가상컬럼
--4. 그룹함수, GROUP BY 절이 포함된 경우
--5. DISTINCT를 포함하고 있는 경우
--6. JOIN으로 여러 테이블이 연결되어있는 경우








